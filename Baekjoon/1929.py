M, N = map(int, (input().split()))

prime = []

for i in range(M, N+1) :
    if i == 1 :
        continue
    for j in range(2, int(i** (1/2))+1) :
        if i % j == 0 :
            break
    else :
        prime.append(i)

for i in prime :
    print(i)

"""
소수를 구하기 위해서는 i % j 를 통해 전부다 나눠보는 방식을 사용할 수 있다.
거듭제곱은 **로 표현하고, 2의 루트 : 2**(1/2) = 1.4142135623730951로 표현
할 수 있다.
해당 문제는 전부다 i % j를 하면 시간이 너무 많이 걸림으로 i** (1/2)를 통해서
문제를 해결 할 수 있다고 한다.
소수를 구할때는 특정수의 제곱근( ex) 3의 제곱근은 루트3)까지만 나눠보면
소수를 구할 수 있다고 한다.
조금 어려우면 한번 읽어보고 특정수의 제곱근까지만 나눠 구해보면 소수를 구할 수
있다고 이해하자! (에라토스테네스의 체도 한번 읽어보기)

ex) i가 5일때 j는 2부터 루트5(2.23606797749979) +1이지만
루트5을 int형으로 하고 +1을 하기 때문에 j는 3이 된다.
5 % 2 = 1 임으로 5는 소수

i가 9일때 j는 2부터 루트9(정수는 3) +1 임으로
9 % 2 = 1
9 % 3 = 0 임으로 9는 소수가 아니게 된다.
"""