n = int(input())
li = [0] * 301
dp = [0] * 301

for i in range(n) :
    li[i] = int(input())
dp[0] = li[0]
dp[1] = li[0] + li[1]
dp[2] = max(li[0]+li[2], li[1]+li[2])

for i in range(3,n) :
    dp[i] = max(dp[i-3]+li[i-1]+li[i], dp[i-2]+li[i])
print(dp[i])

"""
dp[0]의 경우는 첫번째 계단을 올랐을때를 뜻하고
dp[1]은 첫번째를 밟고, 한칸 올라갔을 경우 이다.
dp[2]의 경우는 첫번째를 밟고 두칸 올랐을때와 두번째를 밟고 한칸 올랐을때 중 최대값이 dp[2]가 된다.

dp[3]부터는 max(dp[i-3]+li[i-1]+li[i], dp[i-2]+li[i]) 식을 사용하게 되는데
dp[i]의 경우는 그 전까지 값을 기준(최대값을 찾으며 계속 갱신됌)으로
max(전칸에서 올라왔을 경우의 최댓값, 전전칸에서 올라왔을 때의 최댓값)을 구하는 방법으로 문제를 풀 수 있다.
전칸에서 올라왔을 경우의 최대값 = dp[i-3]+li[i-1]+li[i]
전칸에서 올라왔을 경우 (i-3까지의 최대값) + 전칸 + 지금값

전전칸에서 올라왔을 경우의 최대값 = dp[i-2]+li[i]
전전칸의 경우 (i-2까지의 최대값) + 지금값을 더해주면 된다.

dp문제를 풀다보면 점화식을 세우는것에 어려움을 많이 느낀다.
dp문제의 경우 문제를 풀다보면 dp[i]의 값을 구할때는 보통 전값이나 전전값을 기준으로 max를 사용하여 문제를 푸는 경우가 많은것 같다.
이러한 방법도 생각해보며, 꾸준히 문제를 풀어서 점화식을 세우는 연습을 해야겠다.
"""